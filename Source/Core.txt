package magedinapotha;

import java.awt.Dimension;
import java.awt.List;
import java.awt.Toolkit;
import java.io.*;
import java.net.ConnectException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Random;
import javax.sound.sampled.*;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;

public class Core extends Thread implements Database {
    //Database Implementation - Start    
    private Connection connection = null;
    private Statement stmt = null;
    private String sql = "";
    private ResultSet result = null;
    
    public boolean EstablishConnection(){
        try {
            Class.forName("org.sqlite.JDBC").newInstance();
            connection = DriverManager.getConnection("jdbc:sqlite:usr/storedEntries.db"); 
            stmt=connection.createStatement();
            return true;
        }catch(SQLException ex){
            JOptionPane.showMessageDialog(null, ex.toString());
            
        }catch(ClassNotFoundException ex){
            JOptionPane.showMessageDialog(null, ex.toString());
            
        }catch(Exception ex){
            JOptionPane.showMessageDialog(null, ex.toString());
            
        }
        return false;
    }    
    public void CloseConnection(){        
        try{
            result.close();
            stmt.close();
            connection.close();
        }catch (SQLException ex){
            JOptionPane.showMessageDialog(null, ex.toString());
            
        }
    }
    
    public String getLoginTable(){
        return 
            "CREATE TABLE IF NOT EXISTS loginD(" +
                "uniqCode            INTEGER PRIMARY KEY AUTOINCREMENT," +
                "password            VARCHAR2(20)    NOT NULL," +
                "secQuestion         VARCHAR2(20)    NOT NULL," +
                "answer              VARCHAR2(20)    NOT NULL," +
                "lastLogged          DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP"+
            ")";
    }
    public String getPersonalTable(){
        return 
            "CREATE TABLE IF NOT EXISTS personalD(" +
                "uniqCode		INTEGER PRIMARY KEY," +
                "fname			VARCHAR2(20)	NOT NULL," +
                "lname			VARCHAR2(20)	NOT NULL," +
                "dob			DATE		NOT NULL," +
                "country		VARCHAR2(20)	NOT NULL," +
                "sex			VARCHAR2(1)     DEFAULT '1'," +
                "email			VARCHAR2(40)	NOT NULL," +
                "mobile			VARCHAR2(20)	NOT NULL," +
                "phone			VARCHAR2(20)	NOT NULL," +
                "FOREIGN KEY (uniqCode) REFERENCES loginD (uniqCode)" +
            ")";
    }
    public String getTextEntries(){
        return 
            "CREATE TABLE IF NOT EXISTS textEntries(" +
                "uID			INTEGER PRIMARY KEY   AUTOINCREMENT," +
                "logged			DATE            NOT NULL," +
                "filename		VARCHAR2(10)	NOT NULL," +
                "UNIQUE (logged)" +
            ")";
    }
    public String getAudioEntries(){
        return 
            "CREATE TABLE IF NOT EXISTS audioEntries(" +
                "uID			INTEGER PRIMARY KEY   AUTOINCREMENT," +
                "logged			DATE            NOT NULL," +
                "filename		VARCHAR2(10)	NOT NULL," +
                "UNIQUE (logged)" +
            ")";
    }
    public String getVideoEntries(){
        return 
            "CREATE TABLE IF NOT EXISTS videoEntries(" +
                "uID			INTEGER PRIMARY KEY   AUTOINCREMENT," +
                "logged			DATE            NOT NULL," +
                "filename		VARCHAR2(10)	NOT NULL," +
                "UNIQUE (logged)" +
            ")";
    }
    
    public boolean CreateCoreDatabase(){
        try {
            if(EstablishConnection()){//If connection established    
                updateQuery(getLoginTable());//Creates Personal Table         
                updateQuery(getPersonalTable());//Creates Personal Table
                updateQuery(getTextEntries());//Create Text Entry Table
                updateQuery(getAudioEntries());//Creates Audio Entry Table                
                updateQuery(getVideoEntries());//Create Video Entry Table                
                
                CloseConnection();
                return true;
            }
        }catch(Exception ex){
            JOptionPane.showMessageDialog(null, ex.toString());
        }
        return false;
    }
    public ResultSet executeQuery(String query){
        
        if(EstablishConnection()){
            try{            
                result=stmt.executeQuery(query);
                return result;
            }catch(SQLException ex){
                JOptionPane.showMessageDialog(null, ex.toString());
            }
        }
        return result;
    }  
    public boolean updateQuery(String query){
        try{            
            stmt.executeUpdate(query);
            return true;
        }catch(SQLException ex){
            JOptionPane.showMessageDialog(null, ex.toString());
        }
        return false;
    }
    public boolean getResults(String query){
        if(EstablishConnection()){
            try{
                result=stmt.executeQuery(query);
                CloseConnection();
                return true;
            }catch (SQLException ex){
                JOptionPane.showMessageDialog(null, ex.toString());
            }
        }
        return false;
    }
    
    public boolean insertInto(String table,String columns,String values){
        String query="INSERT INTO "+table+" ("+columns+") VALUES ("+values+")";
        if(updateQuery(query)){
            return true;
        }
        return false;
    }
    public boolean insertInto(String table,String values){
        String query="INSERT INTO "+table+" VALUES ("+values+")";
        if(updateQuery(query)){
            return true;
        }
        return false;
    }
    public ResultSet select(String table){//Get All Columns
        return executeQuery("SELECT * FROM "+table);
    }
    public ResultSet select(String columns,String table){//Get Specified Columns
        return executeQuery("SELECT "+columns+" FROM "+table);
    }
    public ResultSet select(String columns, String table, String where){//Get records according to specified condition;
        return executeQuery("SELECT "+columns+" FROM "+table+" WHERE "+where);
    }
    //Database Implementation - End
    
    //Core Functionality - Start
    public String stripLine(String line){
        String[] data = line.trim().split("=");
        return data[1].replace(" ", "");
    }
    
    private static final String string = "0123456789abcdefghijklmnopqrstuvwxyz";
    private Random random = new Random();
    public String generateRandomString(){//Generate a 8 character random string
        StringBuilder sb = new StringBuilder(8);
        String text;
        for(int i=0;i<8;i++) {
            text=String.valueOf(string.charAt(random.nextInt(string.length())));
            if(text.matches("[0-9]*") && i==0)//Check to see if the first is not a number
                text=String.valueOf(string.charAt(random.nextInt(string.length())));
           sb.append(text);
        }
        return sb.toString();
    }
    //Core Functionality - End
    
    //Thread Code - Start
    private boolean[] makeThreadActive=new boolean [2];
    //0 - Splash Screen, 
    public void setThreadItem(String boolName,boolean value){//Determine Which Part of the thread to run
        switch(boolName){
            case "Splash"://If the Thread is to be run in the splash screen
                makeThreadActive[0]=value;
                break;
            case "Audio"://If the Thread is to be run in the AddAudioEntry Screen
                makeThreadActive[1]=value;
                break;
        }
    }
    
    //Splash Screen - Start 
    private JLabel lblSplashProgress = new JLabel();
    private JLabel lblSplashText = new JLabel();
    Core core;
    Splash splash;
    public void setSplashLabel(JLabel progress,JLabel text,Core c,Splash s){//Get the Frame, Core Object, and the Labels
        lblSplashProgress=progress;
        lblSplashText=text;
        core = c;
        splash=s;
    }
    private void setSplashProgress(){//Show Splash Screen Progress and Run Thread
        try{
            int width=0;//Width of the progress bar
            for(int i=0;i<40;i+=25){//Loop through the progress
                if(width> 390){//Stop the thread          
                    splash.setVisible(false);//close the splash screen
                    if(readFile("usr/settings.config")){//Reads Configuration File
                        if(stripLine(getReadFileData().get(0)).matches("1")){//If Application run first time       
                            FirstRun f = new FirstRun();
                            f.show();                            
                        }else{
                            SignIn l = new SignIn();
                            l.show();
                        }
                    }            
                    core.stop();//Stop the thread
                }
                width=lblSplashProgress.getWidth()+i;
                lblSplashProgress.setSize(width, 37); 
                Thread.sleep(250); 
                if(width < 40){//Show different loading sections
                    if(width>10 & width<30)
                        lblSplashText.setText("Retrieving Stored Encrypted Data");
                    else if(width>30 && width<50)
                        lblSplashText.setText("Loading Core Functions");
                    else if(width>50)
                        lblSplashText.setText("Loading Diary Entries");
                }   
            }
        }catch(Exception e){}
    }
    //Splash Screen - End
    
    public void run(){//Main Thread Run Function
        while(true){
            if(makeThreadActive[0]){
                setSplashProgress();
            }
        }
    }    
    //Thread Code - End
    
    //IO Operations - Start
    private ArrayList<String> readFileData = new ArrayList<String>();//Data from Read File Stored Here
    
    public ArrayList<String> getReadFileData(){//Return the Read File Array List
        return readFileData;
    }
    public boolean isFilePresent(File file){//Check if file is available   
        if(file.exists()){
            return true;
        }
        return false;
    }    
    public boolean readFile(String filename){
        File file = new File(filename);
        BufferedReader bufferReader=null;
        readFileData.clear();
        try{
            if(isFilePresent(file)){
                bufferReader = new BufferedReader(new FileReader(file));
                String line="";
                while((line = bufferReader.readLine()) != null){
                    readFileData.add(line);
                }
                bufferReader.close();
                return true;
            }else//Create a new file if file not present
                file.createNewFile();
            
        }catch(Exception ex){
            
        }
        return false;
    }
    public boolean appendFile(String filename,String data){//Append Data to File
        File file = new File(filename); 
        try {         
            if(!isFilePresent(file))//Creates a new file if not exists
                file.createNewFile();
            
            FileWriter writer = new FileWriter(file.getName(),true);
            BufferedWriter bufferWritter = new BufferedWriter(writer);
            
    	    bufferWritter.write(data);//Append the Data
            
    	    bufferWritter.close();//Close the buffer writer
            writer.close();//Close the file writer
            
            return true;
        }catch(IOException ex) {

        }catch(Exception ex){

        }             
        return false;
    }
    public boolean writeFile(String filename,String data){//Write data to a new file
        File file = new File(filename); 
        try {            
            FileWriter writer = new FileWriter(file);     
            BufferedWriter bufferWriter = new BufferedWriter(writer);
            
            writer.write(data);    
            
            bufferWriter.close();
            writer.close();   
            
            return true;
        }catch(IOException ex) {

        }catch(Exception ex){

        }             
        return false;
    }
    //IO Operations - End
    
    //Audio and Video Core - Start
    public void captureWebcam(){
        
    }
    //Auido - Start
    // record duration, in milliseconds
    private long recordTime = 60000;  // 1 minute   
    private File audioFile;// path of the wav file
    TargetDataLine line;    // the line from which audio data is captured
    AudioFileFormat.Type fileType;    
    
    public long getRecordTime(){//Return Record TIme
        return recordTime;
    }
    public void setRecordTime(long rTime){//Set Record Time
        recordTime=rTime;
    }
    
    private AudioFormat getAudioFormat() {//Audio Format Details
        float sampleRate = 16000;
        int sampleSizeInBits = 8;
        int channels = 2;
        boolean signed = true;
        boolean bigEndian = true;
        AudioFormat format = new AudioFormat(sampleRate, sampleSizeInBits,channels, signed, bigEndian);
        return format;
    }
    public void initRecorder(){//Initialize the recorder controls 
        audioFile = new File("RecordAudio.wav");// path of the wav file
        fileType = AudioFileFormat.Type.WAVE;// format of audio file
    }    
    public void startAudioRecording() {//Start Recording
        try {
            AudioFormat format = getAudioFormat();
            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
 
            // checks if system supports the data line
            if (!AudioSystem.isLineSupported(info)) {
                System.out.println("Line not supported");
                System.exit(0);
            }
            line = (TargetDataLine) AudioSystem.getLine(info);
            line.open(format);
            line.start();   // start capturing 
            
            JOptionPane.showMessageDialog(null, "Start");
 
            AudioInputStream ais = new AudioInputStream(line);
 
            JOptionPane.showMessageDialog(null, "Start Recording");
 
            // start recording
            AudioSystem.write(ais, fileType, audioFile); 
        } catch (LineUnavailableException ex) {
            ex.printStackTrace();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }    
    public void stopAudioRecording() {//Stop Recording
        line.stop();
        line.close();
        System.out.println("Finished");
    }    
    
    public float level;
    final static float MAX_8_BITS_SIGNED = Byte.MAX_VALUE;
    final static float MAX_8_BITS_UNSIGNED = 0xff;
    final static float MAX_16_BITS_SIGNED = Short.MAX_VALUE;
    final static float MAX_16_BITS_UNSIGNED = 0xffff;
    
    private void calculateLevel (byte[] buffer,
                                 int readPoint,
                                 int leftOver) {
        int max = 0;
        boolean use16Bit = (getAudioFormat().getSampleSizeInBits() == 16);
        boolean signed = (getAudioFormat().getEncoding() ==
                          AudioFormat.Encoding.PCM_SIGNED);
        boolean bigEndian = (getAudioFormat().isBigEndian());
        if (use16Bit) {
            for (int i=readPoint; i<buffer.length-leftOver; i+=2) {
                int value = 0;
                // deal with endianness
                int hiByte = (bigEndian ? buffer[i] : buffer[i+1]);
                int loByte = (bigEndian ? buffer[i+1] : buffer [i]);
                if (signed) {
                    short shortVal = (short) hiByte;
                    shortVal = (short) ((shortVal << 8) | (byte) loByte);
                    value = shortVal;
                } else {
                    value = (hiByte << 8) | loByte;
                }
                max = Math.max(max, value);
            } // for
        } else {
            // 8 bit - no endianness issues, just sign
            for (int i=readPoint; i<buffer.length-leftOver; i++) {
                int value = 0;
                if (signed) {
                    value = buffer [i];
                } else {
                    short shortVal = 0;
                    shortVal = (short) (shortVal | buffer [i]);
                    value = shortVal;
                }
                max = Math.max (max, value);
            } // for
        } // 8 bit
        // express max as float of 0.0 to 1.0 of max value
        // of 8 or 16 bits (signed or unsigned)
        if (signed) {
            if (use16Bit) { level = (float) max / MAX_16_BITS_SIGNED; }
            else { level = (float) max / MAX_8_BITS_SIGNED; }
        } else {
            if (use16Bit) { level = (float) max / MAX_16_BITS_UNSIGNED; }
            else { level = (float) max / MAX_8_BITS_UNSIGNED; }
        }
    }
    //Audio - End
    //Audio and Video Core - End
    
    //Look and Feel - Start
    public void centerFrame(JFrame frame){//Center JFrame
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        int xAxis = screenSize.width/2-frame.getSize().width/2;//Get X Axis
        int yAxis = screenSize.height/2-frame.getSize().height/2;//Get Y Axis
        frame.setLocation(xAxis, yAxis);//Set Frame Location from new X and Y axis
    }
    //Look and Feel - End
}